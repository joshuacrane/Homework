{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 .SFNSText;\f2\fnil\fcharset0 HelveticaNeue;
\f3\fnil\fcharset0 Menlo-Regular;\f4\fnil\fcharset0 Menlo-Bold;\f5\fnil\fcharset0 Menlo-Italic;
}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;\red255\green255\blue255;\red38\green38\blue38;
\red0\green0\blue0;\red152\green0\blue127;\red38\green38\blue38;\red252\green95\blue163;\red31\green31\blue36;
\red255\green255\blue255;\red122\green200\blue182;\red150\green134\blue245;\red174\green243\blue125;\red153\green232\blue213;
\red145\green212\blue98;\red108\green121\blue134;}
{\*\expandedcolortbl;;\cssrgb\c20022\c20022\c19997;\cssrgb\c100000\c100000\c100000\c0;\cssrgb\c20044\c20044\c19994;
\cssrgb\c0\c0\c0;\cssrgb\c66847\c5271\c57017;\cssrgb\c20000\c20000\c20000;\csgenericrgb\c98839\c37355\c63833;\csgenericrgb\c12054\c12284\c14131;
\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c47716\c78607\c71403;\csgenericrgb\c58752\c52717\c95948;\csgenericrgb\c68215\c95290\c48909;\csgenericrgb\c59926\c90967\c83488;
\csgenericrgb\c56799\c83212\c38450;\csgenericrgb\c42394\c47462\c52518;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}.}{\leveltext\leveltemplateid201\'01.;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 /*\
Closures: 
\f1 \cf2 \cb3 \expnd0\expndtw0\kerning0
self-contained blocks of functionality that can be passed around and used in your code. Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as\'a0closing over\'a0those constants and variables. Swift handles all of the memory management of capturing for you.\
\
\pard\pardeftab720\sl420\partightenfactor0

\f2 \cf4 Closures take one of three forms:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl420\partightenfactor0
\ls1\ilvl0\cf4 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Global functions are closures that have a name and do not capture any values.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Nested functions are closures that have a name and can capture values from their enclosing function.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.
\f1 \cf2 \
\pard\tx720\pardeftab720\sl420\partightenfactor0
\cf2 \
\pard\pardeftab720\sl420\partightenfactor0
\cf2 Swift\'92s closure optimizations: \
\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl420\partightenfactor0
\ls2\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Inferring parameter and return value types from context\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Implicit returns from single-expression closures\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Shorthand argument names\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Trailing closure syntax\
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \
Closure Syntax:
\f2 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl532\partightenfactor0
\ls3\ilvl0
\f3 \cf2 \kerning1\expnd0\expndtw0 {\listtext	.	}\expnd0\expndtw0\kerning0
\{ (\cf5 parameters\cf2 ) -> \cf5 return type\cf2  \cf6 in\cf2 \
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	.	}\expnd0\expndtw0\kerning0
    \cf5 statements\cf2 \
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	.	}\expnd0\expndtw0\kerning0
\}\
\pard\tx720\pardeftab720\sl532\partightenfactor0

\fs28 \cf7 \cb1 \

\fs24 \cf2 \cb3 Trailing Closures: 
\f1 \cf4 is written after the function call\'92s parentheses, even though it is still an argument to the function
\f3\fs28 \cf7 \cb1 \
\
\pard\pardeftab720\sl420\partightenfactor0

\f2\fs24 \cf2 \cb3 AutoClosures:  a closure that is automatically created to wrap an expression that\'92s being passed as an argument to a function. It doesn\'92t take any arguments, and when it\'92s called, it returns the value of the expression that\'92s wrapped inside of it.\
*/\
\
\
//Ryans Example\
/*\
\pard\tx791\pardeftab791\pardirnatural\partightenfactor0

\f4\b\fs32 \cf8 \cb9 \kerning1\expnd0\expndtw0 import
\f3\b0 \cf10  UIKit
\f0\fs24 \cf0 \
\

\f4\b\fs32 \cf8 func
\f3\b0 \cf10  mySort(array: [\cf11 Int\cf10 ], sortClosure: (\cf11 Int\cf10 , \cf11 Int\cf10 ) -> \cf11 Bool\cf10 ) -> [\cf11 Int\cf10 ] \{
\f0\fs24 \cf0 \

\f3\fs32 \cf10     
\f4\b \cf8 var
\f3\b0 \cf10  sortedArray = \cf11 Array\cf10 (repeating: \cf12 0\cf10 , count: array.\cf11 count\cf10 )
\f0\fs24 \cf0 \

\f3\fs32 \cf10     
\f4\b \cf8 for
\f3\b0 \cf10  firstIndex 
\f4\b \cf8 in
\f3\b0 \cf10  \cf12 0\cf10 ..<array.\cf11 count\cf10  \{
\f0\fs24 \cf0 \

\f3\fs32 \cf10         
\f4\b \cf8 var
\f3\b0 \cf10  correctIndex = \cf12 0
\f0\fs24 \cf0 \

\f3\fs32 \cf10         
\f4\b \cf8 let
\f3\b0 \cf10  firstElement = array[firstIndex]
\f0\fs24 \cf0 \

\f3\fs32 \cf10         
\f4\b \cf8 for
\f3\b0 \cf10  secondIndex 
\f4\b \cf8 in
\f3\b0 \cf10  \cf12 0\cf10 ..<array.\cf11 count\cf10  
\f4\b \cf8 where
\f3\b0 \cf10  firstIndex != secondIndex \{
\f0\fs24 \cf0 \

\f3\fs32 \cf10             
\f4\b \cf8 let
\f3\b0 \cf10  secondElement = array[secondIndex]
\f0\fs24 \cf0 \

\f3\fs32 \cf10             
\f4\b \cf8 if
\f3\b0 \cf10  !sortClosure(firstElement, secondElement) \{
\f0\fs24 \cf0 \

\f3\fs32 \cf10                 correctIndex += \cf12 1
\f0\fs24 \cf0 \

\f3\fs32 \cf10             \}
\f0\fs24 \cf0 \

\f3\fs32 \cf10         \}
\f0\fs24 \cf0 \

\f3\fs32 \cf10         sortedArray[correctIndex] = firstElement
\f0\fs24 \cf0 \

\f3\fs32 \cf10     \}
\f0\fs24 \cf0 \

\f3\fs32 \cf10     
\f4\b \cf8 return
\f3\b0 \cf10  sortedArray
\f0\fs24 \cf0 \

\f3\fs32 \cf10 \}
\f0\fs24 \cf0 \
\

\f4\b\fs32 \cf8 func
\f3\b0 \cf10  myOtherSort(array: [\cf11 Int\cf10 ], sortClosure: (\cf11 Int\cf10 , \cf11 Int\cf10 ) -> \cf11 Bool\cf10 ) -> [\cf11 Int\cf10 ] \{
\f0\fs24 \cf0 \

\f3\fs32 \cf10     
\f4\b \cf8 return
\f3\b0 \cf10  \cf13 mySort\cf10 (array: array, sortClosure: sortClosure)
\f0\fs24 \cf0 \

\f3\fs32 \cf10 \}
\f0\fs24 \cf0 \
\

\f4\b\fs32 \cf8 func
\f3\b0 \cf10  sort(elementOne: \cf11 Int\cf10 , elementTwo: \cf11 Int\cf10 ) -> \cf11 Bool\cf10  \{
\f0\fs24 \cf0 \

\f3\fs32 \cf10     
\f4\b \cf8 return
\f3\b0 \cf10  elementOne < elementTwo
\f0\fs24 \cf0 \

\f3\fs32 \cf10 \}
\f0\fs24 \cf0 \
\

\f4\b\fs32 \cf8 let
\f3\b0 \cf10  sortClosure: (\cf11 Int\cf10 , \cf11 Int\cf10 ) -> \cf11 Bool\cf10  = \{ first, second 
\f4\b \cf8 in
\f0\b0\fs24 \cf0 \

\f3\fs32 \cf10     
\f4\b \cf8 return
\f3\b0 \cf10  first < second
\f0\fs24 \cf0 \

\f3\fs32 \cf10 \}
\f0\fs24 \cf0 \
\

\f4\b\fs32 \cf8 let
\f3\b0 \cf10  myInt: \cf11 Int\cf10  = \cf12 5
\f0\fs24 \cf0 \

\f3\fs32 \cf14 print\cf10 (\cf15 sortClosure\cf10 )
\f0\fs24 \cf0 \
\

\f3\fs32 \cf13 mySort\cf10 (array: [], sortClosure: \{ firstParam, secondParam 
\f4\b \cf8 in
\f0\b0\fs24 \cf0 \

\f3\fs32 \cf10     
\f4\b \cf8 return
\f3\b0 \cf10  firstParam < secondParam
\f0\fs24 \cf0 \

\f3\fs32 \cf10 \})
\f0\fs24 \cf0 \
\

\f4\b\fs32 \cf8 var
\f3\b0 \cf10  testArray = [\cf12 1\cf10 , \cf12 3\cf10 , \cf12 0\cf10 , \cf12 2\cf10 , \cf12 -3\cf10 ]
\f0\fs24 \cf0 \

\f5\i\fs32 \cf16 //testArray.sort(by: >)
\f0\i0\fs24 \cf0 \

\f3\fs32 \cf14 print\cf10 (\cf15 testArray\cf10 )
\f0\fs24 \cf0 \

\f3\fs32 \cf14 print\cf10 (\cf13 mySort\cf10 (array: \cf15 testArray\cf10 , sortClosure: \cf15 sortClosure\cf10 ))
\f0\fs24 \cf0 \

\f3\fs32 \cf14 print\cf10 (\cf13 mySort\cf10 (array: \cf15 testArray\cf10 , sortClosure: \{ (int1, int2) -> \cf11 Bool\cf10  
\f4\b \cf8 in
\f0\b0\fs24 \cf0 \

\f3\fs32 \cf10     
\f4\b \cf8 return
\f3\b0 \cf10  int1 < int2
\f0\fs24 \cf0 \

\f3\fs32 \cf10 \}))
\f0\fs24 \cf0 \

\f3\fs32 \cf13 mySort\cf10 (array: \cf15 testArray\cf10 , sortClosure: \{ (first, second) -> \cf11 Bool\cf10  
\f4\b \cf8 in
\f0\b0\fs24 \cf0 \

\f3\fs32 \cf10     
\f4\b \cf8 return
\f3\b0 \cf10  first > second
\f0\fs24 \cf0 \

\f3\fs32 \cf10     \})
\f0\fs24 \cf0 \

\f3\fs32 \cf14 print\cf10 (\cf13 mySort\cf10 (array: \cf15 testArray\cf10 , sortClosure: \cf13 sort\cf10 ))
\f0\fs24 \cf0 \
\pard\pardeftab720\sl420\partightenfactor0

\f1 \cf2 \cb3 \expnd0\expndtw0\kerning0
*/\
}